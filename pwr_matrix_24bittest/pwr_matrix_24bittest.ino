// Test my 24 bit RGB bitmap display modifications
// works ok with arduino ide 1.5.7 and 1.5.8 (no obvious problems...)
// Paul W. Rogers, Jan 2015

#include <Adafruit_GFX.h>
#include <Adafruit_NeoMatrix.h>
#include <Adafruit_NeoPixel.h>

#ifndef PSTR
 #define PSTR // Make Arduino Due happy
#endif

#define PIN 6
#define ROWS 8
#define COLS 8 
#define MINDELAY 20
#define MAXDELAY 255

// MATRIX DECLARATION:
// Parameter 1 = width of NeoPixel matrix
// Parameter 2 = height of matrix
// Parameter 3 = pin number (most are valid)
// Parameter 4 = matrix layout flags, add together as needed:
//   NEO_MATRIX_TOP, NEO_MATRIX_BOTTOM, NEO_MATRIX_LEFT, NEO_MATRIX_RIGHT:
//     Position of the FIRST LED in the matrix; pick two, e.g.
//     NEO_MATRIX_TOP + NEO_MATRIX_LEFT for the top-left corner.
//   NEO_MATRIX_ROWS, NEO_MATRIX_COLUMNS: LEDs are arranged in horizontal
//     rows or in vertical columns, respectively; pick one or the other.
//   NEO_MATRIX_PROGRESSIVE, NEO_MATRIX_ZIGZAG: all rows/columns proceed
//     in the same order, or alternate lines reverse direction; pick one.
//   See example below for these values in action.
// Parameter 5 = pixel type flags, add together as needed:
//   NEO_KHZ800  800 KHz bitstream (most NeoPixel products w/WS2812 LEDs)
//   NEO_KHZ400  400 KHz (classic 'v1' (not v2) FLORA pixels, WS2811 drivers)
//   NEO_GRB     Pixels are wired for GRB bitstream (most NeoPixel products)
//   NEO_RGB     Pixels are wired for RGB bitstream (v1 FLORA pixels, not v2)

// Example for NeoPixel Shield.  In this application we'd like to use it
// as a 5x8 tall matrix, with the USB port positioned at the top of the
// Arduino.  When held that way, the first pixel is at the top right, and
// lines are arranged in columns, progressive order.  The shield uses
// 800 KHz (v2) pixels that expect GRB color data.

Adafruit_NeoMatrix matrix = Adafruit_NeoMatrix(COLS, ROWS, PIN,
  NEO_MATRIX_TOP     + NEO_MATRIX_RIGHT +
  NEO_MATRIX_COLUMNS + NEO_MATRIX_PROGRESSIVE,
  NEO_GRB            + NEO_KHZ800);

void setup() {
  matrix.begin();
  matrix.setBrightness(40);
}

// ghost1_clr.bmp BMP (11, 8) RGB
// Data table generated by pwr_rgb2c.py (c) Paul Rogers
unsigned char ghost1_clr_x=11;
unsigned char ghost1_clr_y=8;
PROGMEM const uint8_t ghost1_clr_rgb[] = {
   93,244,63 , 93,244,63 , 93,244,63 , 93,244,63 , 93,244,63 , 93,244,63 , 
   93,244,63 , 93,244,63 , 93,244,63 , 93,244,63 , 255,0,0 , 255,0,0 , 
   255,0,0 , 255,0,0 , 255,0,0 , 255,0,0 , 93,244,63 , 255,0,0 , 
   255,0,0 , 255,0,0 , 255,0,0 , 255,0,0 , 255,0,0 , 246,243,13 , 
   255,0,0 , 255,0,0 , 35,230,237 , 35,230,237 , 255,0,0 , 255,0,0 , 
   255,0,0 , 255,0,0 , 255,0,0 , 255,0,0 , 35,230,237 , 0,0,0 , 
   255,0,0 , 255,0,0 , 255,0,0 , 246,243,13 , 255,0,0 , 255,0,0 , 
   255,0,0 , 255,0,0 , 255,0,0 , 255,0,0 , 255,0,0 , 255,0,0 , 
   255,0,0 , 255,0,0 , 35,230,237 , 35,230,237 , 255,0,0 , 255,0,0 , 
   255,0,0 , 246,243,13 , 255,0,0 , 255,0,0 , 35,230,237 , 0,0,0 , 
   255,0,0 , 255,0,0 , 255,0,0 , 255,0,0 , 93,244,63 , 255,0,0 , 
   255,0,0 , 255,0,0 , 255,0,0 , 255,0,0 , 255,0,0 , 246,243,13 , 
   93,244,63 , 93,244,63 , 255,0,0 , 255,0,0 , 255,0,0 , 255,0,0 , 
   255,0,0 , 255,0,0 , 93,244,63 , 93,244,63 , 93,244,63 , 93,244,63 , 
   93,244,63 , 93,244,63 , 93,244,63 , 93,244,63 
};

// testrgb.bmp BMP (8, 8) RGB
// Data table generated by pwr_rgb2c.py (c) Paul Rogers
unsigned char testrgb_x=8;
unsigned char testrgb_y=8;
PROGMEM const unsigned char testrgb_rgb[] = {
   255,0,0 , 255,0,0 , 255,0,0 , 0,255,0 , 0,255,0 , 0,0,255 , 
   0,0,255 , 0,0,255 , 255,0,0 , 255,0,0 , 255,0,0 , 0,255,0 , 
   0,255,0 , 0,0,255 , 0,0,255 , 0,0,255 , 255,0,0 , 255,0,0 , 
   255,0,0 , 0,255,0 , 0,255,0 , 0,0,255 , 0,0,255 , 0,0,255 , 
   255,0,0 , 255,0,0 , 255,0,0 , 0,255,0 , 0,255,0 , 0,0,255 , 
   0,0,255 , 0,0,255 , 255,0,0 , 255,0,0 , 255,0,0 , 0,255,0 , 
   0,255,0 , 0,0,255 , 0,0,255 , 0,0,255 , 255,0,0 , 255,0,0 , 
   255,0,0 , 0,255,0 , 0,255,0 , 0,0,255 , 0,0,255 , 0,0,255 , 
   255,0,0 , 255,0,0 , 255,0,0 , 0,255,0 , 0,255,0 , 0,0,255 , 
   0,0,255 , 0,0,255 , 255,0,0 , 255,0,0 , 255,0,0 , 0,255,0 , 
   0,255,0 , 0,0,255 , 0,0,255 , 0,0,255 
};

// test10x8.bmp BMP (10, 8) RGB
// Data table generated by pwr_rgb2c.py (c) Paul Rogers
unsigned char test10x8_x=10;
unsigned char test10x8_y=8;
PROGMEM const unsigned char test10x8_rgb[] = {
   255,0,0 , 255,0,0 , 255,0,0 , 0,255,0 , 0,255,0 , 0,0,255 , 
   0,0,255 , 0,0,255 , 255,0,0 , 255,0,0 , 255,0,0 , 0,255,0 , 
   0,255,0 , 0,0,255 , 0,0,255 , 0,0,255 , 255,0,0 , 255,0,0 , 
   255,0,0 , 0,255,0 , 0,255,0 , 0,0,255 , 0,0,255 , 0,0,255 , 
   255,0,0 , 255,0,0 , 255,0,0 , 0,255,0 , 0,255,0 , 0,0,255 , 
   0,0,255 , 0,0,255 , 255,0,0 , 255,0,0 , 255,0,0 , 0,255,0 , 
   0,255,0 , 0,0,255 , 0,0,255 , 0,0,255 , 255,0,0 , 255,0,0 , 
   255,0,0 , 0,255,0 , 0,255,0 , 0,0,255 , 0,0,255 , 0,0,255 , 
   255,0,0 , 255,0,0 , 255,0,0 , 0,255,0 , 0,255,0 , 0,0,255 , 
   0,0,255 , 0,0,255 , 255,0,0 , 255,0,0 , 255,0,0 , 0,255,0 , 
   0,255,0 , 0,0,255 , 0,0,255 , 0,0,255 , 255,0,0 , 255,255,255 , 
   255,255,255 , 255,255,255 , 255,255,255 , 255,255,255 , 255,255,255 , 0,0,255 , 
   255,0,0 , 255,0,0 , 255,0,0 , 0,255,0 , 0,255,0 , 255,255,255 , 
   255,255,255 , 0,0,255 
};

// bitmap data in x/y order 3 bytes per pixel, r,g,b. origin (0,0) at top left of bitmap.

byte stage = 0, maxstage=2, x=0, y = 0;

void bitmap24bitrgb()
{ switch (stage)
  { case 0: matrix.drawRGBBitmap(0,0,testrgb_rgb,testrgb_x, testrgb_y);
       break;
    case 1: matrix.drawRGBBitmap(-3,0,test10x8_rgb,test10x8_x, test10x8_y);
       break;
    case 2: matrix.drawRGBBitmap(1,2,ghost1_clr_rgb,ghost1_clr_x, ghost1_clr_y);
       break;
  }
  matrix.show();
}

void loop() 
{ matrix.fillScreen(0);
  matrix.show();
  bitmap24bitrgb();
  if (++stage > maxstage) stage = 0;  
  delay(5000);
}
